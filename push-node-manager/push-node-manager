#!/bin/bash
# Push Node Manager Control Script

set -e

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"

# Source common functions if available (we're outside container)
if [ -f "$SCRIPT_DIR/scripts/common.sh" ]; then
    source "$SCRIPT_DIR/scripts/common.sh"
else
    # Define colors locally if common.sh not available
    GREEN='\033[0;32m'
    BLUE='\033[0;34m'
    RED='\033[0;31m'
    YELLOW='\033[0;33m'
    CYAN='\033[0;36m'
    MAGENTA='\033[0;35m'
    WHITE='\033[1;37m'
    NC='\033[0m'
    BOLD='\033[1m'
    
    # Define local versions of print functions
    print_status() {
        echo -e "${BLUE}$1${NC}"
    }
    
    print_success() {
        echo -e "${GREEN}$1${NC}"
    }
    
    print_error() {
        echo -e "${RED}$1${NC}"
    }
    
    print_warning() {
        echo -e "${YELLOW}$1${NC}"
    }
fi

# ASCII Art Banner
show_banner() {
    echo -e "${BOLD}${GREEN}"
    echo "    ____             __       ________          _      "
    echo "   / __ \\__  _______/ /_     / ____/ /_  ____ _(_)___  "
    echo "  / /_/ / / / / ___/ __ \\   / /   / __ \\/ __ \`/ / __ \\ "
    echo " / ____/ /_/ (__  ) / / /  / /___/ / / / /_/ / / / / / "
    echo "/_/    \\__,_/____/_/ /_/   \\____/_/ /_/\\__,_/_/_/ /_/  "
    echo -e "${NC}"
    echo -e "${BOLD}${YELLOW}          Push Node Manager v1.0.0${NC}"
    echo -e "${GREEN}        ═══════════════════════════════${NC}"
    echo
}

# Load environment
if [ -f .env ]; then
    export $(cat .env | grep -v '^#' | xargs)
fi

# Docker compose command (support both old and new versions)
if docker compose version &> /dev/null; then
    DOCKER_COMPOSE="docker compose"
else
    DOCKER_COMPOSE="docker-compose"
fi


# Show banner for interactive commands (not for status checks)
case "$1" in
    start|stop|restart|register-validator|setup|monitor|sync|validators|help|"")
        show_banner
        ;;
esac

# Main commands
case "$1" in
    start)
        print_status "🚀 Starting Push node container..."
        
        # Check if already running
        if $DOCKER_COMPOSE ps | grep -q "push-node-manager.*Up"; then
            print_warning "⚠️  Node container is already running!"
            print_status "Check status with: ./push-node-manager status"
            exit 0
        fi
        
        # Build image if needed
        if ! docker images | grep -q "push-node-manager.*local"; then
            print_status "🔨 Building validator image..."
            $DOCKER_COMPOSE build
        fi
        
        # Start services
        $DOCKER_COMPOSE up -d
        
        # Check for AppHash errors in first 10 seconds
        print_status "🔍 Checking for sync issues..."
        sleep 5
        
        if $DOCKER_COMPOSE logs --tail=50 2>&1 | grep -q "wrong Block.Header.AppHash"; then
            print_error "❌ AppHash mismatch detected - blockchain data incompatible with genesis"
            echo ""
            echo "This usually happens when:"
            echo "1. Genesis file was updated"
            echo "2. Switching between networks"
            echo "3. Blockchain data is corrupted"
            echo ""
            read -p "Would you like to clean data and restart? (yes/no): " -r
            if [[ $REPLY =~ ^[Yy][Ee][Ss]$ ]]; then
                print_status "🧹 Cleaning blockchain data..."
                $DOCKER_COMPOSE down -v
                print_status "🚀 Starting fresh..."
                $DOCKER_COMPOSE up -d
                print_success "✅ Validator restarted with clean data!"
            else
                print_warning "⚠️  Validator may not sync properly without cleaning data"
            fi
        else
            echo
            echo -e "${GREEN}╔═══════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║      ✅ NODE STARTED SUCCESSFULLY! ✅     ║${NC}"
            echo -e "${GREEN}╚═══════════════════════════════════════════╝${NC}"
        fi
        
        echo
        echo -e "${BOLD}Next steps:${NC}"
        echo -e "  ${BOLD}Check sync status:${NC}   ${YELLOW}./push-node-manager status${NC}"
        echo -e "  ${BOLD}View logs:${NC}           ${YELLOW}./push-node-manager logs${NC}"
        echo -e "  ${BOLD}Become a validator:${NC} ${YELLOW}./push-node-manager register-validator${NC}"
        ;;
        
    stop)
        print_status "🛑 Stopping Push node container..."
        $DOCKER_COMPOSE down
        echo
        echo -e "${YELLOW}╔═══════════════════════════════════════╗${NC}"
        echo -e "${YELLOW}║      ⏹️  NODE STOPPED SAFELY ⏹️        ║${NC}"
        echo -e "${YELLOW}╚═══════════════════════════════════════╝${NC}"
        echo
        echo -e "${BOLD}To restart:${NC} ${YELLOW}./push-node-manager start${NC}"
        ;;
        
    restart)
        print_status "🔄 Restarting validator..."
        $DOCKER_COMPOSE restart
        print_success "✅ Validator restarted"
        ;;
        
    status)
        print_status "📊 Validator Status"
        echo -e "${GREEN}══════════════════════════════════════════${NC}"
        
        # First check if Docker is running
        if ! docker info >/dev/null 2>&1; then
            echo
            echo -e "${RED}╔═══════════════════════════════════════╗${NC}"
            echo -e "${RED}║      ❌ DOCKER IS NOT RUNNING ❌      ║${NC}"
            echo -e "${RED}╚═══════════════════════════════════════╝${NC}"
            echo
            echo -e "${YELLOW}💡 Please start Docker first${NC}"
            exit 1
        fi
        
        # Check if container exists
        if ! docker ps -a --format '{{.Names}}' | grep -q "push-node-manager"; then
            echo
            echo -e "${RED}╔═══════════════════════════════════════╗${NC}"
            echo -e "${RED}║   ❌ VALIDATOR NOT INITIALIZED ❌     ║${NC}"
            echo -e "${RED}╚═══════════════════════════════════════╝${NC}"
            echo
            echo -e "${YELLOW}💡 Run '${BOLD}./push-node-manager start${NC}${YELLOW}' to initialize${NC}"
            exit 1
        fi
        
        # Check if container is running
        if ! docker ps --format '{{.Names}}' | grep -q "push-node-manager"; then
            echo
            echo -e "${RED}╔═══════════════════════════════════════╗${NC}"
            echo -e "${RED}║    ❌ VALIDATOR IS STOPPED ❌         ║${NC}"
            echo -e "${RED}╚═══════════════════════════════════════╝${NC}"
            echo
            echo -e "${YELLOW}💡 Start with: ${BOLD}./push-node-manager start${NC}"
            exit 1
        fi
        
        # Get node status
        NODE_STATUS=$($DOCKER_COMPOSE exec -T validator pchaind status --home /root/.pchain 2>/dev/null)
        
        if [ -z "$NODE_STATUS" ]; then
            print_warning "⏳ Node is starting up..."
            echo "This can take a few minutes. Try again shortly."
            echo ""
            echo "You can check logs with: ./push-node-manager logs"
            exit 0
        fi
        
        # Parse and display local node status with colors
        echo
        echo -e "${BOLD}${BLUE}Node Information:${NC}"
        echo -e "${GREEN}─────────────────────────────────────────${NC}"
        
        NODE_INFO=$(echo "$NODE_STATUS" | jq -r '"\(.node_info.id)|\(.node_info.network)|\(.node_info.moniker)|\(.node_info.version)"' 2>/dev/null)
        IFS='|' read -r NODE_ID NETWORK MONIKER VERSION <<< "$NODE_INFO"
        
        echo -e "  ${BOLD}Node ID:${NC} ${YELLOW}$NODE_ID${NC}"
        echo -e "  ${BOLD}Network:${NC} ${GREEN}$NETWORK${NC}"
        echo -e "  ${BOLD}Moniker:${NC} ${BOLD}${WHITE}$MONIKER${NC}"
        echo -e "  ${BOLD}Version:${NC} $VERSION"
        
        echo
        echo -e "${BOLD}${BLUE}Sync Status:${NC}"
        echo -e "${GREEN}─────────────────────────────────────────${NC}"
        
        # Extract sync info
        SYNC_INFO=$(echo "$NODE_STATUS" | jq -r '"\(.sync_info.latest_block_height)|\(.sync_info.latest_block_time)|\(.sync_info.catching_up)"' 2>/dev/null)
        IFS='|' read -r LOCAL_HEIGHT LATEST_TIME CATCHING_UP <<< "$SYNC_INFO"
        
        echo -e "  ${BOLD}Block Height:${NC} ${GREEN}$LOCAL_HEIGHT${NC}"
        echo -e "  ${BOLD}Block Time:${NC} $LATEST_TIME"
        
        # Color code catching up status
        if [ "$CATCHING_UP" = "false" ]; then
            echo -e "  ${BOLD}Status:${NC} ${GREEN}✅ Fully Synced${NC}"
        else
            echo -e "  ${BOLD}Status:${NC} ${YELLOW}⏳ Syncing...${NC}"
        fi
        
        # Get remote node status to show sync progress
        # Try to get from genesis node using curl
        REMOTE_STATUS=$(curl -s --connect-timeout 5 http://34.57.209.0:26657/status 2>/dev/null || echo "")
        
        if [ -n "$REMOTE_STATUS" ]; then
            REMOTE_HEIGHT=$(echo "$REMOTE_STATUS" | jq -r '.result.sync_info.latest_block_height // "unknown"' 2>/dev/null || echo "unknown")
            if [ "$REMOTE_HEIGHT" != "unknown" ] && [ "$REMOTE_HEIGHT" != "null" ]; then
                LOCAL_HEIGHT=$(echo "$NODE_STATUS" | jq -r '.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
                
                # Calculate sync percentage
                if [ "$REMOTE_HEIGHT" -gt 0 ] && [ "$LOCAL_HEIGHT" -gt 0 ]; then
                    SYNC_PERCENT=$(awk -v local=$LOCAL_HEIGHT -v remote=$REMOTE_HEIGHT 'BEGIN {printf "%.1f", (local/remote)*100}')
                    BLOCKS_BEHIND=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                    
                    echo "  Remote Block Height: $REMOTE_HEIGHT"
                    
                    # Calculate ETA based on sync speed
                    # First, get the previous block height from a temp file
                    TEMP_FILE="/tmp/push_node_manager_sync_status"
                    CURRENT_TIME=$(date +%s)
                    
                    if [ -f "$TEMP_FILE" ]; then
                        # Read previous data
                        PREV_DATA=$(cat "$TEMP_FILE" 2>/dev/null || echo "")
                        PREV_HEIGHT=$(echo "$PREV_DATA" | cut -d',' -f1 2>/dev/null || echo "0")
                        PREV_TIME=$(echo "$PREV_DATA" | cut -d',' -f2 2>/dev/null || echo "0")
                        
                        if [ "$PREV_HEIGHT" -gt 0 ] && [ "$PREV_TIME" -gt 0 ]; then
                            # Calculate blocks per second
                            TIME_DIFF=$((CURRENT_TIME - PREV_TIME))
                            HEIGHT_DIFF=$((LOCAL_HEIGHT - PREV_HEIGHT))
                            
                            if [ "$TIME_DIFF" -gt 0 ] && [ "$HEIGHT_DIFF" -gt 0 ]; then
                                BLOCKS_PER_SEC=$(awk -v diff=$HEIGHT_DIFF -v time=$TIME_DIFF 'BEGIN {printf "%.2f", diff/time}')
                                
                                # Calculate ETA in seconds
                                BPS_CHECK=$(echo "$BLOCKS_PER_SEC" | awk '{print ($1 > 0)}')
                                if [ "$BPS_CHECK" -eq 1 ]; then
                                    ETA_SECONDS=$(awk -v behind=$BLOCKS_BEHIND -v bps=$BLOCKS_PER_SEC 'BEGIN {printf "%d", behind/bps}')
                                    
                                    # Convert to human readable format
                                    if [ "$ETA_SECONDS" -lt 60 ]; then
                                        ETA_STRING="${ETA_SECONDS}s"
                                    elif [ "$ETA_SECONDS" -lt 3600 ]; then
                                        ETA_MINUTES=$((ETA_SECONDS / 60))
                                        ETA_STRING="${ETA_MINUTES}m"
                                    elif [ "$ETA_SECONDS" -lt 86400 ]; then
                                        ETA_HOURS=$((ETA_SECONDS / 3600))
                                        ETA_MINUTES=$(((ETA_SECONDS % 3600) / 60))
                                        ETA_STRING="${ETA_HOURS}h ${ETA_MINUTES}m"
                                    else
                                        ETA_DAYS=$((ETA_SECONDS / 86400))
                                        ETA_HOURS=$(((ETA_SECONDS % 86400) / 3600))
                                        ETA_STRING="${ETA_DAYS}d ${ETA_HOURS}h"
                                    fi
                                    
                                    SPEED_STRING="$(printf "%.1f" $BLOCKS_PER_SEC) blocks/s"
                                else
                                    ETA_STRING="calculating..."
                                    SPEED_STRING="measuring..."
                                fi
                            else
                                ETA_STRING="calculating..."
                                SPEED_STRING="measuring..."
                            fi
                        else
                            ETA_STRING="calculating..."
                            SPEED_STRING="measuring..."
                        fi
                    else
                        ETA_STRING="calculating..."
                        SPEED_STRING="measuring..."
                    fi
                    
                    # Save current data for next run
                    echo "$LOCAL_HEIGHT,$CURRENT_TIME" > "$TEMP_FILE"
                    
                    # Create progress bar
                    BAR_LENGTH=30
                    FILLED_LENGTH=$(awk -v percent=$SYNC_PERCENT -v bar=$BAR_LENGTH 'BEGIN {printf "%d", (percent/100)*bar}')
                    
                    # Build the progress bar
                    PROGRESS_BAR="["
                    for ((i=0; i<$BAR_LENGTH; i++)); do
                        if [ $i -lt $FILLED_LENGTH ]; then
                            PROGRESS_BAR="${PROGRESS_BAR}▓"
                        else
                            PROGRESS_BAR="${PROGRESS_BAR}░"
                        fi
                    done
                    PROGRESS_BAR="${PROGRESS_BAR}]"
                    
                    # Color code the sync progress
                    if [ $(echo "$SYNC_PERCENT" | awk '{print ($1 >= 99)}') -eq 1 ]; then
                        echo -e "  Sync Progress: ${GREEN}${PROGRESS_BAR} ${SYNC_PERCENT}%${NC}"
                        echo -e "  Blocks Behind: ${GREEN}$BLOCKS_BEHIND${NC} | Speed: $SPEED_STRING | ETA: $ETA_STRING"
                    elif [ $(echo "$SYNC_PERCENT" | awk '{print ($1 >= 90)}') -eq 1 ]; then
                        echo -e "  Sync Progress: ${YELLOW}${PROGRESS_BAR} ${SYNC_PERCENT}%${NC}"
                        echo -e "  Blocks Behind: ${YELLOW}$BLOCKS_BEHIND${NC} | Speed: $SPEED_STRING | ETA: $ETA_STRING"
                    else
                        echo -e "  Sync Progress: ${RED}${PROGRESS_BAR} ${SYNC_PERCENT}%${NC}"
                        echo -e "  Blocks Behind: ${RED}$BLOCKS_BEHIND${NC} | Speed: $SPEED_STRING | ETA: $ETA_STRING"
                    fi
                else
                    echo "  Remote Block Height: $REMOTE_HEIGHT"
                fi
            fi
        fi
        
        # Show validator info
        echo
        echo -e "${BOLD}${BLUE}Validator Info:${NC}"
        echo -e "${GREEN}─────────────────────────────────────────${NC}"
        
        VOTING_POWER=$(echo "$NODE_STATUS" | jq -r '.validator_info.voting_power // "0"' 2>/dev/null || echo "0")
        
        if [ "$VOTING_POWER" != "0" ] && [ "$VOTING_POWER" != "null" ]; then
            echo -e "  ${BOLD}Voting Power:${NC} ${GREEN}$VOTING_POWER${NC} ${GREEN}✅ Active Validator${NC}"
        else
            echo -e "  ${BOLD}Voting Power:${NC} ${YELLOW}0${NC} ${YELLOW}⚠️  Not a validator yet${NC}"
            echo
            echo -e "  ${YELLOW}💡 To become a validator:${NC}"
            echo -e "     Run ${BOLD}${GREEN}'./push-node-manager register-validator'${NC}"
            echo
            echo -e "  This wizard will guide you through:"
            echo -e "     ${GREEN}•${NC} Creating/importing a wallet"
            echo -e "     ${GREEN}•${NC} Getting tokens from the faucet"
            echo -e "     ${GREEN}•${NC} Registering as a validator"
        fi
        ;;
        
    logs)
        # Optional: filter by service
        SERVICE="${2:-validator}"
        TAIL="${3:-100}"
        
        print_status "📜 Showing logs for $SERVICE (last $TAIL lines)..."
        $DOCKER_COMPOSE logs -f --tail=$TAIL $SERVICE
        ;;
        
    backup)
        print_status "💾 Creating secure backup..."
        
        # Create backup directory
        BACKUP_DIR="backups"
        mkdir -p "$BACKUP_DIR"
        
        # Run secure backup script inside container
        $DOCKER_COMPOSE exec -T validator /scripts/backup-keys.sh backup || {
            # Fallback to simple backup if new script not available
            print_warning "Using simple backup method..."
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            $DOCKER_COMPOSE exec -T validator tar -czf - \
                /root/.pchain/config/priv_validator_key.json \
                /root/.pchain/config/node_key.json \
                /root/.pchain/data/priv_validator_state.json 2>/dev/null \
                > "$BACKUP_DIR/node-keys-${TIMESTAMP}.tar.gz"
            print_success "✅ Backup complete: $BACKUP_DIR/node-keys-${TIMESTAMP}.tar.gz"
        }
        
        # Also backup local config
        if [ -f .env ]; then
            cp .env "$BACKUP_DIR/.env.backup"
        fi
        ;;
        
    shell)
        print_status "🐚 Opening shell in validator container..."
        $DOCKER_COMPOSE exec validator /bin/sh
        ;;
        
    reset-data)
        print_warning "⚠️  This will reset blockchain data only!"
        echo "Your wallets and validator keys will be preserved."
        echo "Use this to fix sync issues or clear corrupted data."
        echo ""
        echo "Choose reset method:"
        echo "1) Quick reset (node stays running)"
        echo "2) Clean reset (stop node and remove volumes)"
        read -p "Choose option (1-2): " reset_option
        
        case "$reset_option" in
            1)
                # Check if container is running
                if ! $DOCKER_COMPOSE ps | grep -q "push-node-manager.*Up"; then
                    print_error "❌ Node is not running!"
                    echo "Start the node first: ./push-node-manager start"
                    exit 1
                fi
                
                if [[ $(read -p "Proceed with quick reset? (yes/no): " -r && echo $REPLY) == "yes" ]]; then
                    print_status "🔄 Resetting blockchain data..."
                    $DOCKER_COMPOSE exec -T validator pchaind tendermint unsafe-reset-all --home /root/.pchain
                    print_success "✅ Blockchain data reset"
                    echo "Restart your node to begin syncing: ./push-node-manager restart"
                else
                    echo "Reset cancelled"
                fi
                ;;
            2)
                if [[ $(read -p "Proceed with clean reset? (yes/no): " -r && echo $REPLY) == "yes" ]]; then
                    print_status "🛑 Stopping validator..."
                    $DOCKER_COMPOSE down -v
                    
                    # Also remove host data directory
                    if [ -d "./data" ]; then
                        print_status "🗑️  Removing host data directory..."
                        rm -rf ./data
                    fi
                    
                    print_success "✅ Blockchain data cleaned"
                    echo "Start fresh with: ./push-node-manager start"
                else
                    echo "Reset cancelled"
                fi
                ;;
            *)
                print_error "Invalid option"
                ;;
        esac
        ;;
        
    reset-all)
        print_error "🚨 DANGER: Complete Reset!"
        echo "This will DELETE EVERYTHING:"
        echo "  • All blockchain data"
        echo "  • All wallets and keys"
        echo "  • All validator configuration"
        echo "  • Docker volumes and images"
        echo ""
        echo "You will need to:"
        echo "  1. Create new wallets"
        echo "  2. Get new tokens from faucet"
        echo "  3. Re-register as validator"
        echo ""
        read -p "Type 'DELETE' to confirm: " -r
        if [[ $REPLY == "DELETE" ]]; then
            # Call the reset script with skip-confirm flag
            if [ -f "$SCRIPT_DIR/reset-node-manager.sh" ]; then
                bash "$SCRIPT_DIR/reset-node-manager.sh" --skip-confirm
            else
                print_error "Reset script not found!"
                exit 1
            fi
        else
            echo "Reset cancelled"
        fi
        ;;
        
    keys)
        # Key management subcommands
        case "$2" in
            list)
                $DOCKER_COMPOSE exec -T validator pchaind keys list --keyring-backend test --home /root/.pchain
                ;;
            add)
                KEY_NAME="${3:-validator}"
                print_status "🔑 Creating new key: $KEY_NAME"
                $DOCKER_COMPOSE exec validator pchaind keys add $KEY_NAME --keyring-backend test --home /root/.pchain
                ;;
            show)
                KEY_NAME="${3:-validator}"
                $DOCKER_COMPOSE exec -T validator pchaind keys show $KEY_NAME --keyring-backend test --home /root/.pchain
                ;;
            *)
                echo "Usage: ./push-node-manager keys {list|add|show} [key-name]"
                ;;
        esac
        ;;
        
    update)
        print_status "🔄 Updating validator..."
        git pull
        $DOCKER_COMPOSE pull
        print_success "✅ Update complete. Restart validator to apply changes."
        ;;
        
    validators|list-validators)
        print_status "📋 Active Validators"
        echo "=================="
        
        # Get validators from genesis node
        print_status "Fetching validator list..."
        
        VALIDATORS_JSON=$(curl -s --connect-timeout 10 http://34.57.209.0:26657/validators 2>/dev/null || echo "")
        
        if [ -n "$VALIDATORS_JSON" ] && [ "$VALIDATORS_JSON" != "" ]; then
            # Try staking validators for more detailed info
            STAKING_VALIDATORS=$($DOCKER_COMPOSE exec -T validator pchaind query staking validators --node tcp://34.57.209.0:26657 --output json 2>/dev/null || echo "")
            
            if [ -n "$STAKING_VALIDATORS" ] && [ "$STAKING_VALIDATORS" != "null" ]; then
                # Get total count
                VALIDATOR_COUNT=$(echo "$STAKING_VALIDATORS" | jq '.validators | length' 2>/dev/null || echo "0")
                echo -e "${BOLD}Total Validators: $VALIDATOR_COUNT${NC}"
                echo
                
                # Get user's validator address if available
                USER_VALIDATOR_ADDR=""
                if docker ps --format '{{.Names}}' | grep -q "push-node-manager"; then
                    # Try to get the first wallet address
                    USER_WALLET_ADDR=$($DOCKER_COMPOSE exec -T validator pchaind keys list --keyring-backend test --home /root/.pchain 2>/dev/null | grep -A 1 "address:" | grep -v "address:" | head -1 | tr -d '[:space:]' || echo "")
                fi
                
                # Parse and display validators without table (for full display)
                for i in $(seq 0 $((VALIDATOR_COUNT - 1))); do
                    MONIKER=$(echo "$STAKING_VALIDATORS" | jq -r ".validators[$i].description.moniker // \"Unknown\"" 2>/dev/null)
                    STATUS=$(echo "$STAKING_VALIDATORS" | jq -r ".validators[$i].status // \"UNKNOWN\"" 2>/dev/null)
                    TOKENS=$(echo "$STAKING_VALIDATORS" | jq -r ".validators[$i].tokens // \"0\"" 2>/dev/null)
                    OPERATOR_ADDR=$(echo "$STAKING_VALIDATORS" | jq -r ".validators[$i].operator_address // \"\"" 2>/dev/null)
                    
                    # Convert tokens to PUSH
                    VOTING_POWER=$(echo "$TOKENS" | awk '{printf "%.2f", $1/1000000000000000000}')
                    
                    # Format status
                    case "$STATUS" in
                        "BOND_STATUS_BONDED")
                            STATUS_TEXT="BONDED"
                            STATUS_COLOR="${GREEN}"
                            ;;
                        "BOND_STATUS_UNBONDING")
                            STATUS_TEXT="UNBONDING"
                            STATUS_COLOR="${YELLOW}"
                            ;;
                        "BOND_STATUS_UNBONDED")
                            STATUS_TEXT="UNBONDED"
                            STATUS_COLOR="${RED}"
                            ;;
                        *)
                            STATUS_TEXT="UNKNOWN"
                            STATUS_COLOR="${NC}"
                            ;;
                    esac
                    
                    # Rank
                    RANK=$((i + 1))
                    
                    # Format voting power
                    VP_DISPLAY="${VOTING_POWER} PUSH"
                    
                    # Print full information without truncation
                    echo
                    echo -e "${BOLD}Validator #$RANK${NC}"
                    echo -e "  ${CYAN}Name:${NC}     $MONIKER"
                    echo -e "  ${CYAN}Address:${NC}  $OPERATOR_ADDR"
                    echo -e "  ${CYAN}Status:${NC}   ${STATUS_COLOR}$STATUS_TEXT${NC}"
                    echo -e "  ${CYAN}Power:${NC}    $VP_DISPLAY"
                    
                    # Check if this is the user's validator
                    if [ -n "$USER_VALIDATOR_ADDR" ] && echo "$OPERATOR_ADDR" | grep -q "$USER_VALIDATOR_ADDR"; then
                        echo -e "  ${GREEN}★ This is your validator${NC}"
                    fi
                done
                
                echo
                echo -e "${BLUE}Note: Validators are ranked by voting power${NC}"
            else
                # Fallback to basic validator info
                VALIDATOR_COUNT=$(echo "$VALIDATORS_JSON" | jq '.result.validators | length' 2>/dev/null || echo "0")
                echo -e "${BOLD}Total Validators: $VALIDATOR_COUNT${NC}"
                echo
                
                echo "$VALIDATORS_JSON" | jq -r '.result.validators[] | 
                    "• Address: \(.address) - Voting Power: \(.voting_power)"' 2>/dev/null || \
                    print_error "Failed to parse validator data"
            fi
        else
            print_error "Could not fetch validator list"
            echo "Make sure your node is running and connected to the network"
        fi
        ;;
        
    sync)
        # Live sync monitoring
        print_status "🔄 Live Sync Monitor (Ctrl+C to exit)..."
        echo "Starting in 3 seconds..."
        sleep 3
        
        # Hide cursor for cleaner display
        tput civis
        
        # Restore cursor on exit
        trap 'tput cnorm; exit' INT TERM
        
        # Clear screen once
        clear
        
        while true; do
            # Move cursor to home position (top-left)
            tput cup 0 0
            
            echo -e "${BOLD}${BLUE}Push Chain Sync Monitor${NC}  ${YELLOW}[Ctrl+C to exit]${NC}"
            echo "====================================================="
            echo "Time: $(date)"
            echo ""
            
            # Get node status
            NODE_STATUS=$($DOCKER_COMPOSE exec -T validator pchaind status --home /root/.pchain 2>/dev/null)
            
            if [ -n "$NODE_STATUS" ]; then
                # Parse local status
                LOCAL_HEIGHT=$(echo "$NODE_STATUS" | jq -r '.sync_info.latest_block_height // "0"' 2>/dev/null || echo "0")
                CATCHING_UP=$(echo "$NODE_STATUS" | jq -r '.sync_info.catching_up // true' 2>/dev/null || echo "true")
                LATEST_TIME=$(echo "$NODE_STATUS" | jq -r '.sync_info.latest_block_time // "unknown"' 2>/dev/null || echo "unknown")
                
                echo -e "${BOLD}Local Node:${NC}"
                echo "  Block Height: $LOCAL_HEIGHT"
                echo "  Block Time: $LATEST_TIME"
                echo "  Syncing: $CATCHING_UP"
                echo ""
                
                # Get remote status
                REMOTE_STATUS=$(curl -s --connect-timeout 5 http://34.57.209.0:26657/status 2>/dev/null || echo "")
                
                if [ -n "$REMOTE_STATUS" ]; then
                    REMOTE_HEIGHT=$(echo "$REMOTE_STATUS" | jq -r '.result.sync_info.latest_block_height // "unknown"' 2>/dev/null || echo "unknown")
                    
                    if [ "$REMOTE_HEIGHT" != "unknown" ] && [ "$REMOTE_HEIGHT" != "null" ] && [ "$REMOTE_HEIGHT" -gt 0 ] && [ "$LOCAL_HEIGHT" -gt 0 ]; then
                        echo -e "${BOLD}Network:${NC}"
                        echo "  Latest Height: $REMOTE_HEIGHT"
                        
                        # Calculate sync percentage
                        SYNC_PERCENT=$(awk -v local=$LOCAL_HEIGHT -v remote=$REMOTE_HEIGHT 'BEGIN {printf "%.2f", (local/remote)*100}')
                        BLOCKS_BEHIND=$((REMOTE_HEIGHT - LOCAL_HEIGHT))
                        
                        # Calculate speed and ETA
                        TEMP_FILE="/tmp/push_node_manager_sync_monitor"
                        CURRENT_TIME=$(date +%s)
                        
                        if [ -f "$TEMP_FILE" ]; then
                            PREV_DATA=$(cat "$TEMP_FILE" 2>/dev/null || echo "")
                            PREV_HEIGHT=$(echo "$PREV_DATA" | cut -d',' -f1 2>/dev/null || echo "0")
                            PREV_TIME=$(echo "$PREV_DATA" | cut -d',' -f2 2>/dev/null || echo "0")
                            
                            if [ "$PREV_HEIGHT" -gt 0 ] && [ "$PREV_TIME" -gt 0 ]; then
                                TIME_DIFF=$((CURRENT_TIME - PREV_TIME))
                                HEIGHT_DIFF=$((LOCAL_HEIGHT - PREV_HEIGHT))
                                
                                if [ "$TIME_DIFF" -gt 0 ] && [ "$HEIGHT_DIFF" -gt 0 ]; then
                                    BLOCKS_PER_SEC=$(awk -v diff=$HEIGHT_DIFF -v time=$TIME_DIFF 'BEGIN {printf "%.1f", diff/time}')
                                    
                                    BPS_CHECK=$(echo "$BLOCKS_PER_SEC" | awk '{print ($1 > 0)}')
                                    if [ "$BPS_CHECK" -eq 1 ]; then
                                        ETA_SECONDS=$(awk -v behind=$BLOCKS_BEHIND -v bps=$BLOCKS_PER_SEC 'BEGIN {printf "%d", behind/bps}')
                                        
                                        # Convert to human readable
                                        if [ "$ETA_SECONDS" -lt 60 ]; then
                                            ETA_STRING="${ETA_SECONDS}s"
                                        elif [ "$ETA_SECONDS" -lt 3600 ]; then
                                            ETA_MINUTES=$((ETA_SECONDS / 60))
                                            ETA_STRING="${ETA_MINUTES}m"
                                        elif [ "$ETA_SECONDS" -lt 86400 ]; then
                                            ETA_HOURS=$((ETA_SECONDS / 3600))
                                            ETA_MINUTES=$(((ETA_SECONDS % 3600) / 60))
                                            ETA_STRING="${ETA_HOURS}h ${ETA_MINUTES}m"
                                        else
                                            ETA_DAYS=$((ETA_SECONDS / 86400))
                                            ETA_HOURS=$(((ETA_SECONDS % 86400) / 3600))
                                            ETA_STRING="${ETA_DAYS}d ${ETA_HOURS}h"
                                        fi
                                    else
                                        BLOCKS_PER_SEC="0.0"
                                        ETA_STRING="calculating..."
                                    fi
                                else
                                    BLOCKS_PER_SEC="0.0"
                                    ETA_STRING="calculating..."
                                fi
                            else
                                BLOCKS_PER_SEC="0.0"
                                ETA_STRING="measuring..."
                            fi
                        else
                            BLOCKS_PER_SEC="0.0"
                            ETA_STRING="measuring..."
                        fi
                        
                        # Save current data
                        echo "$LOCAL_HEIGHT,$CURRENT_TIME" > "$TEMP_FILE"
                        
                        echo ""
                        echo -e "${BOLD}Sync Progress:${NC}"
                        
                        # Create progress bar with activity indicator
                        BAR_LENGTH=50
                        FILLED_LENGTH=$(awk -v percent=$SYNC_PERCENT -v bar=$BAR_LENGTH 'BEGIN {printf "%d", (percent/100)*bar}')
                        
                        # Add animated activity indicator for active syncing
                        ACTIVITY_FRAMES=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
                        FRAME_INDEX=$(($(date +%s) % 10))
                        ACTIVITY="${ACTIVITY_FRAMES[$FRAME_INDEX]}"
                        
                        PROGRESS_BAR="["
                        for ((i=0; i<$BAR_LENGTH; i++)); do
                            if [ $i -lt $FILLED_LENGTH ]; then
                                PROGRESS_BAR="${PROGRESS_BAR}▓"
                            elif [ $i -eq $FILLED_LENGTH ] && [ "$CATCHING_UP" = "true" ]; then
                                # Show activity at the edge of progress
                                PROGRESS_BAR="${PROGRESS_BAR}${ACTIVITY}"
                            else
                                PROGRESS_BAR="${PROGRESS_BAR}░"
                            fi
                        done
                        PROGRESS_BAR="${PROGRESS_BAR}]"
                        
                        # Color based on progress
                        if [ $(echo "$SYNC_PERCENT" | awk '{print ($1 >= 99)}') -eq 1 ]; then
                            COLOR="${GREEN}"
                        elif [ $(echo "$SYNC_PERCENT" | awk '{print ($1 >= 90)}') -eq 1 ]; then
                            COLOR="${YELLOW}"
                        else
                            COLOR="${RED}"
                        fi
                        
                        # Calculate percentage increase
                        PERCENT_INCREASE=""
                        if [ -f "$TEMP_FILE.last_percent" ]; then
                            LAST_PERCENT=$(cat "$TEMP_FILE.last_percent")
                            PERCENT_DIFF=$(awk -v curr=$SYNC_PERCENT -v last=$LAST_PERCENT 'BEGIN {printf "%.3f", curr - last}')
                            
                            if [ $(awk -v diff=$PERCENT_DIFF 'BEGIN {print (diff > 0)}') -eq 1 ]; then
                                PERCENT_INCREASE=" ${GREEN}+${PERCENT_DIFF}%${NC}"
                            fi
                        fi
                        echo "$SYNC_PERCENT" > "$TEMP_FILE.last_percent"
                        
                        echo -e "  Progress: ${COLOR}${PROGRESS_BAR} ${SYNC_PERCENT}%${NC}${PERCENT_INCREASE}"
                        echo -e "  Blocks Behind: ${COLOR}$BLOCKS_BEHIND${NC}"
                        
                        # Show sync speed with activity indicator
                        if [ "$BLOCKS_PER_SEC" != "0.0" ] && [ "$CATCHING_UP" = "true" ]; then
                            echo -e "  Sync Speed: ${GREEN}▶${NC} $BLOCKS_PER_SEC blocks/s"
                            
                            # Show blocks synced in this session
                            if [ -f "$TEMP_FILE.start" ]; then
                                START_HEIGHT=$(cat "$TEMP_FILE.start")
                                START_TIME=$(cat "$TEMP_FILE.start_time" 2>/dev/null || echo "$CURRENT_TIME")
                                BLOCKS_SYNCED=$((LOCAL_HEIGHT - START_HEIGHT))
                                SESSION_TIME=$((CURRENT_TIME - START_TIME))
                                
                                if [ $SESSION_TIME -gt 60 ]; then
                                    AVG_SPEED=$(awk -v synced=$BLOCKS_SYNCED -v time=$SESSION_TIME 'BEGIN {printf "%.1f", synced/time}')
                                    echo -e "  Blocks Synced: ${BOLD}$BLOCKS_SYNCED${NC} (avg: $AVG_SPEED blocks/s)"
                                else
                                    echo -e "  Blocks Synced: ${BOLD}$BLOCKS_SYNCED${NC}"
                                fi
                            else
                                echo "$LOCAL_HEIGHT" > "$TEMP_FILE.start"
                                echo "$CURRENT_TIME" > "$TEMP_FILE.start_time"
                            fi
                        else
                            echo -e "  Sync Speed: $BLOCKS_PER_SEC blocks/s"
                        fi
                        
                        echo -e "  ETA: ${BOLD}$ETA_STRING${NC}"
                        
                        if [ "$CATCHING_UP" = "false" ]; then
                            echo ""
                            echo -e "${GREEN}✅ Fully synced!${NC}"
                        fi
                    fi
                fi
            else
                print_error "Node not responding..."
            fi
            
            # Clear to end of screen to remove any leftover text
            tput ed
            
            # Refresh every 2 seconds for more responsive updates
            sleep 2
        done
        ;;
        
    monitor)
        # Simple monitoring view
        print_status "📊 Monitoring validator (Ctrl+C to exit)..."
        while true; do
            clear
            echo -e "${BLUE}Push Chain Validator Monitor${NC}"
            echo "============================="
            echo "Time: $(date)"
            echo ""
            
            # Get basic status
            if $DOCKER_COMPOSE exec -T validator pchaind status --home /root/.pchain 2>/dev/null | jq -r '
                "Height: \(.sync_info.latest_block_height)
Catching Up: \(.sync_info.catching_up)
Connected: true"
            '; then
                echo ""
            else
                print_error "Node not responding..."
            fi
            
            sleep 5
        done
        ;;
        
    test|health|check)
        # Run comprehensive health check tests
        if [ -f "$SCRIPT_DIR/test-node-manager.sh" ]; then
            print_status "🚀 Running comprehensive health checks..."
            bash "$SCRIPT_DIR/test-node-manager.sh"
        else
            print_error "Test script not found!"
            exit 1
        fi
        ;;
        
    register-validator|setup)
        # Interactive wallet setup and validator registration
        print_status "🚀 Starting validator registration wizard..."
        echo
        echo -e "${BOLD}This wizard will help you:${NC}"
        echo -e "  ${GREEN}✓${NC} Create or import a wallet"
        echo -e "  ${GREEN}✓${NC} Get test tokens from the faucet"
        echo -e "  ${GREEN}✓${NC} Register your node as a validator"
        echo
        $DOCKER_COMPOSE exec -it validator /scripts/setup-node-registration.sh
        ;;
        
    auto-register|register)
        # Automatic registration for CI/CD deployments
        print_status "⚡ Starting automatic validator registration..."
        
        # This command is designed for automated deployments where:
        # 1. Wallet is already created and funded
        # 2. You want minimal interaction
        
        # Check for wallet name parameter or use first available wallet
        WALLET_NAME="${2:-}"
        
        if [ -z "$WALLET_NAME" ]; then
            # Try to get the first available wallet
            WALLET_NAME=$($DOCKER_COMPOSE exec -T validator pchaind keys list --keyring-backend test --home /root/.pchain --output json 2>/dev/null | jq -r '.[0].name // empty' 2>/dev/null || echo "")
            
            if [ -z "$WALLET_NAME" ]; then
                print_error "❌ No wallet found!"
                echo ""
                echo "For automated registration, you need to:"
                echo "1. First run: ./push-node-manager setup (to create/import wallet)"
                echo "2. Fund the wallet with at least 1.3 PUSH"
                echo "3. Then run: ./push-node-manager auto-register [wallet-name]"
                echo ""
                echo "For interactive setup, use: ./push-node-manager setup"
                exit 1
            fi
            print_status "Using first available wallet: $WALLET_NAME"
        else
            # Check if specified wallet exists
            if ! $DOCKER_COMPOSE exec -T validator pchaind keys show "$WALLET_NAME" --keyring-backend test --home /root/.pchain >/dev/null 2>&1; then
                print_error "❌ Wallet '$WALLET_NAME' not found!"
                echo ""
                echo "Available wallets:"
                $DOCKER_COMPOSE exec -T validator pchaind keys list --keyring-backend test --home /root/.pchain 2>/dev/null | grep -E "^\s*name:" | sed 's/.*name: /  - /'
                exit 1
            fi
        fi
        
        # Get current balance
        ADDRESS=$($DOCKER_COMPOSE exec -T validator pchaind keys show "$WALLET_NAME" -a --keyring-backend test --home /root/.pchain 2>/dev/null | tr -d '\r')
        print_status "Using wallet '$WALLET_NAME': $ADDRESS"
        
        # Run auto-registration with defaults
        # Input sequence:
        # 1 = Use existing wallet
        # shoaib = wallet name (or the detected wallet name)
        # Push-Validator = validator name
        # (empty) = website
        # (empty) = email
        # (empty) = description
        # 1 = stake amount
        # yes = confirm registration
        cat << EOF | $DOCKER_COMPOSE exec -T validator /scripts/setup-node-registration.sh
1
$WALLET_NAME
Push-Validator



1
yes
EOF
        ;;
        
    balance|wallet)
        # Check wallet balance
        WALLET_NAME="${2:-validator}"
        print_status "💰 Checking wallet balance..."
        
        # Get address
        ADDRESS=$($DOCKER_COMPOSE exec -T validator pchaind keys show $WALLET_NAME -a --keyring-backend test --home /root/.pchain 2>/dev/null | tr -d '\r')
        
        if [ -n "$ADDRESS" ]; then
            echo "Wallet: $WALLET_NAME"
            echo "Address: $ADDRESS"
            
            # Get balance from RPC
            BALANCE=$($DOCKER_COMPOSE exec -T validator pchaind query bank balances $ADDRESS --node tcp://localhost:26657 -o json 2>/dev/null | \
                jq -r '.balances[] | select(.denom=="upc") | .amount // "0"' || echo "0")
            
            if [ "$BALANCE" != "0" ] && [ -n "$BALANCE" ]; then
                # Convert to PUSH (divide by 10^18) using awk instead of bc
                PUSH_AMOUNT=$(awk -v bal="$BALANCE" 'BEGIN {printf "%.6f", bal/1000000000000000000}')
                print_success "Balance: $PUSH_AMOUNT PUSH"
            else
                print_warning "Balance: 0 PUSH"
                
                # Convert to EVM address for faucet
                EVM_ADDRESS=$($DOCKER_COMPOSE exec -T validator pchaind debug addr $ADDRESS 2>/dev/null | grep "hex" | awk '{print "0x"$3}')
                
                if [ -n "$EVM_ADDRESS" ]; then
                    echo
                    echo "To get test tokens:"
                    echo -e "${GREEN}1. Visit: https://faucet.push.org${NC}"
                    echo -e "${GREEN}2. Use this address: ${BOLD}$EVM_ADDRESS${NC}"
                else
                    echo "Get test tokens at: https://faucet.push.org"
                fi
            fi
        else
            print_error "Wallet '$WALLET_NAME' not found"
            echo "Run './push-node-manager setup' to create a wallet"
        fi
        ;;
        
    help|--help|-h)
        cat << EOF
${GREEN}═══════════════════════════════════════════════════════${NC}

Usage: ./push-node-manager [command] [options]

$(echo -e "${BOLD}Commands:${NC}")
$(echo -e "${BOLD}${GREEN}Docker Container Management:${NC}")
  start              Start the Push node Docker container
  stop               Stop the Push node Docker container  
  restart            Restart the Push node Docker container
  shell              Open shell inside the node container

$(echo -e "${BOLD}${GREEN}Node Operations:${NC}")
  status             Show node sync status and validator info
  sync               Live sync monitor with progress bar (Ctrl+C to exit)
  logs               Show node logs (live tail)
  monitor            Simple monitoring dashboard (Ctrl+C to exit)
  test               Run comprehensive health checks

$(echo -e "${BOLD}${GREEN}Validator Management:${NC}")
  register-validator Interactive wizard to become a validator
  validators         List all active validators on the network
  auto-register      Automatic validator registration (uses first wallet or specify name)

$(echo -e "${BOLD}${GREEN}Wallet & Keys:${NC}")
  balance            Check wallet balance and show faucet info
  backup             Backup validator keys to ./backup/ directory
  keys               Key management subcommands:
                       list              - List all wallets
                       add <name>        - Create new wallet
                       show <name>       - Show wallet address
                       delete <name>     - Delete wallet (careful!)

$(echo -e "${BOLD}${GREEN}Maintenance:${NC}")
  reset-data         Reset blockchain data (keeps wallets)
  reset-all          $(echo -e "${RED}DANGER:${NC}") Complete reset - deletes EVERYTHING!
  update             Update node software to latest version
  help               Show this help message

$(echo -e "${BOLD}Examples:${NC}")
$(echo -e "${BOLD}Getting Started:${NC}")
  ./push-node-manager start               # Start the Push node container
  ./push-node-manager status              # Check node sync status
  ./push-node-manager sync                # Watch live sync progress
  ./push-node-manager register-validator  # Become a validator (interactive)
  ./push-node-manager auto-register       # Auto-register using first wallet
  ./push-node-manager auto-register mykey # Auto-register using specific wallet

$(echo -e "${BOLD}Daily Operations:${NC}")
  ./push-node-manager logs                # View live node logs
  ./push-node-manager monitor             # Watch node metrics
  ./push-node-manager validators          # List all validators
  ./push-node-manager balance             # Check wallet balance

$(echo -e "${BOLD}Wallet Management:${NC}")
  ./push-node-manager keys list           # List all wallets
  ./push-node-manager keys add mykey      # Create wallet named 'mykey'
  ./push-node-manager keys show mykey     # Show address for 'mykey'
  ./push-node-manager backup              # Backup your keys

$(echo -e "${BOLD}Troubleshooting:${NC}")
  ./push-node-manager test                # Run health checks
  ./push-node-manager reset-data          # Reset blockchain data
  ./push-node-manager logs -f             # Follow logs continuously
  ./push-node-manager shell               # Access container shell

$(echo -e "${BOLD}Network Information:${NC}")
  Chain ID:     push_42101-1
  Network:      Testnet
  RPC:          http://localhost:26657
  API:          http://localhost:1317
  Faucet:       https://faucet.push.org
  Min Stake:    1 PUSH
  
$(echo -e "${BOLD}Important Notes:${NC}")
  • Validator registration requires minimum 1 PUSH + gas fees (~0.1 PUSH)
  • Default wallet name is 'validator'
  • All keys are stored in the Docker volume for persistence
  • Backup your keys regularly using the 'backup' command
  
$(echo -e "${BOLD}Reset Options Explained:${NC}")
  • $(echo -e "${YELLOW}reset-data${NC}") - Reset blockchain data only (keeps wallets)
                 Option 1: Quick reset (node stays running)
                 Option 2: Clean reset (stops node, removes volumes)
                 Use when: Sync issues, corrupted data, AppHash errors
  • $(echo -e "${RED}reset-all${NC}")  - DELETES EVERYTHING including wallets!
                 Use when: Complete fresh start needed
                 Warning: Requires new wallet creation & tokens

$(echo -e "${BOLD}Troubleshooting:${NC}")
  • If validator won't start: ./push-node-manager logs
  • If sync is stuck: ./push-node-manager reset-data (option 2)
  • If balance shows 0: Check with genesis node (network might be syncing)
  • For detailed debugging: ./push-node-manager shell
  • AppHash errors: ./push-node-manager reset-data (clears incompatible data)

For documentation: Coming soon
For support: Coming soon
EOF
        ;;
        
    *)
        print_error "Unknown command: $1"
        echo "Run './push-node-manager help' for usage information"
        exit 1
        ;;
esac